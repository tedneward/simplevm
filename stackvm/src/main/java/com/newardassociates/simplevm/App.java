/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.newardassociates.simplevm;

import java.util.Map;
import java.util.HashMap;

class Bytecode {
    public static final int NOP = 0;
    public static final int DUMP = 1;
    public static final int PRINT = 2;
    public static final int HALT = 255;

    public static final int CONST = 10;
    public static final int LDC = 11;
    public static final int POP = 12;

    public static final int ADD = 30;
    public static final int SUB = 31;
    public static final int MUL = 32;
    public static final int DIV = 33;
    public static final int MOD = 34;

    // Comparison ops
    public static final int EQ = 40;
    public static final int NE = 41;
    public static final int LT = 42;
    public static final int GT = 43;
    public static final int LTE = 44;
    public static final int GTE = 45;

    // Branching ops
    public static final int JMP = 50;
    public static final int JT = 51;
    public static final int JF = 52;

    // Storage ops
    public static final int GSTORE = 60;
    public static final int GLOAD = 61;
    public static final int LSTORE = 62;
    public static final int LLOAD = 63;

    // Function ops
    public static final int CALL = 20;  // call direct
    public static final int CALLI = 21; // call indirect
    public static final int RET = 22;

    public static String disassemble(int[] code) {
        String result = "";
        for (int i=0; i<code.length; i++) {
            result += String.format("%04d: ", i);
            switch (code[i]) {
                case NOP: result += "NOP"; break;
                case DUMP: result += "DUMP"; break;
                case PRINT: result += "PRINT"; break;

                case CONST: result += "CONST " + code[++i]; break;
                case LDC: result += "LDC " + code[++i]; break;
                case POP: result += "POP"; break;

                case ADD: result += "ADD"; break;
                case SUB: result += "SUB"; break;
                case MUL: result += "MUL"; break;
                case DIV: result += "DIV"; break;
                case MOD: result += "MOD"; break;

                case EQ: result += "EQ"; break;
                case NE: result += "NE"; break;
                case LT: result += "LT"; break;
                case LTE: result += "LTE"; break;
                case GT: result += "GT"; break;
                case GTE: result += "GTE"; break;

                case GSTORE: result += "GSTORE " + code[++i]; break;
                case GLOAD: result += "GLOAD " + code[++i]; break;
                case LSTORE: result += "LSTORE " + code[++i]; break;
                case LLOAD: result += "LLOAD " + code[++i]; break;

                case JMP: result += "JMP " + code[++i]; break;
                case JT: result += "JT " + code[++i]; break;
                case JF: result += "JF " + code[++i]; break;

                case CALL: result += "CALL " + code[++i]; break;
                case CALLI: result += "CALLI"; break;
                case RET: result += "RET"; break;

                default: result += "?" + code[i] + "?"; break;
            }
            result += "\n";
        }
        return result;
    }
}

class Function {
    String name;
    int[] code;
    Function(String name, int[] code) {
        this.name = name; this.code = code;
    }

    public String toShortString() {
        return "[" + name + "]";
    }

    public String toString() {
        return "[" + name + "]: " + 
            Bytecode.disassemble(code);
    }
}

class StackFrame {
    Function fn;
    int ip = 0;

    int[] locals = new int[10];

    public StackFrame(Function f) {
        this.fn = f;
    }

    public String toString() {
        String localStr = " Locals: ";
        for (int i=0; i<10; i++) {
            localStr += i + "=" + locals[i] + " ";
        }
        return fn.toShortString() + 
            " IP: " + ip + 
            " Locals: " + localStr;
    }
}

public class App {
    boolean trace = false;

    Map<Integer, Object> constantPool = new HashMap<>();

    int[] memory = new int[100];

    Object[] stack = new Object[100];
    int sp = -1;

    StackFrame[] frames = new StackFrame[100];
    int fp = -1;

    public void push(Object it) { stack[++sp] = it; }
    public Object pop() { return stack[sp--]; }
    public StackFrame fp() { return frames[fp]; }

    public void execute() {
        // Execute the main function
        Function main = (Function)constantPool.get(Integer.MAX_VALUE);
        StackFrame mainFrame = new StackFrame(main);
        execute(mainFrame);
    }
    public void execute(StackFrame frame) {
        frames[++fp] = frame;

        while (fp().ip < fp().fn.code.length) {
            int op = fp().fn.code[fp().ip++];
            switch (op) {
                case Bytecode.NOP: {
                    // Nothing to do here
                    break;
                }

                case Bytecode.DUMP: {
                    System.out.println("VM Dump:");
                    System.out.println(dumpConstantPool());
                    System.out.println(dumpCallStack());
                    System.out.println(dumpStack());
                    break;
                }

                case Bytecode.PRINT: {
                    System.out.println(pop());
                    break;
                }

                case Bytecode.CONST: {
                    int operand = fp().fn.code[fp().ip++];
                    push(operand);
                    break;
                }
                case Bytecode.LDC: {
                    int cpIndex = fp().fn.code[fp().ip++];
                    push(constantPool.get(cpIndex));
                    break;
                }
                case Bytecode.POP: {
                    pop();
                    break;
                }

                case Bytecode.ADD:
                case Bytecode.SUB:
                case Bytecode.MUL:
                case Bytecode.DIV:
                case Bytecode.MOD:
                {
                    int rhs = (int)pop();
                    int lhs = (int)pop();
                    int result = 0;
                    switch (op) {
                        case Bytecode.ADD: result = lhs + rhs; break;
                        case Bytecode.SUB: result = lhs - rhs; break;
                        case Bytecode.MUL: result = lhs * rhs; break;
                        case Bytecode.DIV: result = lhs / rhs; break;
                        case Bytecode.MOD: result = lhs % rhs; break;
                    }
                    push(result);
                    break;
                }

                case Bytecode.EQ: 
                case Bytecode.NE: 
                case Bytecode.LT: 
                case Bytecode.LTE: 
                case Bytecode.GT: 
                case Bytecode.GTE:
                {
                    int rhs = (int)pop();
                    int lhs = (int)pop();
                    int result = 0;
                    switch (op) {
                        case Bytecode.EQ: result = (lhs == rhs ? 1 : 0); break;
                        case Bytecode.NE: result = (lhs != rhs ? 1 : 0); break;
                        case Bytecode.LT: result = (lhs < rhs ? 1 : 0); break;
                        case Bytecode.LTE: result = (lhs <= rhs ? 1 : 0); break;
                        case Bytecode.GT: result = (lhs > rhs ? 1 : 0); break;
                        case Bytecode.GTE: result = (lhs >= rhs ? 1 : 0); break;
                    }
                    push(result);
                    break;
                }

                case Bytecode.JMP: {
                    int target = fp().fn.code[fp().ip++];
                    fp().ip = target;
                    break;
                }
                case Bytecode.JT: {
                    int target = fp().fn.code[fp().ip++];
                    int test = (int)pop();
                    if (test != 0) {
                        fp().ip = target;
                    }
                    break;
                }
                case Bytecode.JF: {
                    int target = fp().fn.code[fp().ip++];
                    int test = (int)pop();
                    if (test == 0) {
                        fp().ip = target;
                    }
                    break;
                }

                case Bytecode.GSTORE: {
                    int address = fp().fn.code[fp().ip++];
                    int value = (int)pop();
                    memory[address] = value;
                    break;
                }
                case Bytecode.GLOAD: {
                    int address = fp().fn.code[fp().ip++];
                    push(memory[address]);
                    break;
                }
                case Bytecode.LSTORE: {
                    int address = fp().fn.code[fp().ip++];
                    fp().locals[address] = (int)pop();
                    break;
                }
                case Bytecode.LLOAD: {
                    int address = fp().fn.code[fp().ip++];
                    push(fp().locals[address]);
                    break;
                }

                case Bytecode.CALL:
                case Bytecode.CALLI: {
                    int fnIdx = (op == Bytecode.CALL ? 
                        fp().fn.code[fp().ip++] :
                        (Integer)pop() );
                    Function call = (Function)constantPool.get(fnIdx);
                    StackFrame newFrame = new StackFrame(call);
                    execute(newFrame);
                    break;
                }
                case Bytecode.RET: {
                    // Do we need to do anything with the stack to clean up?
                    // Not as long as we manually keep the stack balanced

                    // Blow this frame away and exit execute() entirely
                    frames[fp--] = null;
                    return;
                }

                default: {
                    RuntimeException ex = 
                        new RuntimeException("Unrecognized opcode: " + op);
                    throw ex;
                }
            }
        }

        frames[fp--] = null;
    }

    String dumpConstantPool() {
        String result = "\tConstant Pool: {\n";
        for (int key : constantPool.keySet()) {
            result += "\t\t" + key + ": " + constantPool.get(key) + "\n";
        }
        result += "\t}";
        return result;
    }
    String dumpStack() {
        String result = "\tStack: {\n";
        int i = sp;
        while (i > -1) {
            result += "\t\t" + i + ": " + stack[i] + "\n";
            i--;
        }
        result += "\t}";
        return result;
    }
    String dumpCallStack() {
        String result = "\tCall stack: {\n";
        int i = fp;
        while (i > -1) {
            result += "\t\t" + frames[i] + "\n";
            i--;
        }
        result += "\t}";
        return result;
    }

    public static void main(String[] args) {
        App a = new App();

        int[] nopCode = new int[] { Bytecode.NOP };
        //a.execute(nopCode);

        int[] dumpCode = new int[] { Bytecode.DUMP };
        //a.execute(dumpCode);

        a = new App();
        int[] stackManip = new int[] { 
            Bytecode.CONST, 47,
            Bytecode.CONST, 23,
            Bytecode.LDC, 0,
            Bytecode.LDC, 1,
            Bytecode.DUMP
        };
        a.constantPool.put(0, 100);
        a.constantPool.put(1, 200);
        //a.execute(stackManip);

        a = new App();
        int[] add = new int[] {
            Bytecode.CONST, 1,
            Bytecode.CONST, 2,
            Bytecode.DUMP,
            Bytecode.ADD,
            //Bytecode.RET
        };
        a.constantPool.put(0, new Function("add", add));
        int[] main = new int[] {
            Bytecode.CALL, 0,
            Bytecode.CONST, 0, Bytecode.CALLI,
            Bytecode.ADD
        };
        a.constantPool.put(Integer.MAX_VALUE, new Function("main", main));
        //a.execute();

        a = new App();
        a.constantPool.put(Integer.MAX_VALUE, new Function("main", new int[] {
            Bytecode.CONST, 1,
            Bytecode.JT, 5,
            Bytecode.HALT,
            Bytecode.DUMP
        }));
        a.constantPool.put(0, new Function("add", new int[] {
            Bytecode.DUMP,
            Bytecode.ADD
        }));
        //a.execute();

        a = new App();
        a.constantPool.put(0, new Function("countdown", new int[] {
            Bytecode.CONST, 5,
            Bytecode.LSTORE, 0,
            Bytecode.LLOAD, 0,
            Bytecode.PRINT,
            Bytecode.LLOAD, 0,
            Bytecode.CONST, 1,
            Bytecode.SUB,
            Bytecode.LSTORE, 0,
            Bytecode.LLOAD, 0,
            Bytecode.CONST, 0,
            Bytecode.EQ,
            Bytecode.JF, 4
        }));
        a.constantPool.put(Integer.MAX_VALUE, new Function("main", new int[] {
            Bytecode.CALL, 0
        }));
        a.execute();

        a = new App();
        a.trace = true;
        a.constantPool.put(0, new Function("fibonacci", new int[] {
            // Load globals[0]
            Bytecode.GLOAD, 0,
            Bytecode.LSTORE, 0,
            // Is it 0?
            Bytecode.LLOAD, 0,
            Bytecode.EQ, 0,
            Bytecode.JT, 14,
            Bytecode.CONST, 0,
            Bytecode.PRINT,
            Bytecode.RET,
            // Is it 1?
            Bytecode.LLOAD, 0,
            Bytecode.EQ, 1,
            Bytecode.JT, 24,
            Bytecode.CONST, 1,
            Bytecode.PRINT,
            Bytecode.RET,
            // It's 2 or more
            Bytecode.LLOAD, 0,
            Bytecode.CONST, 1,
            Bytecode.SUB,
            Bytecode.CALL, 0 // call "fibonacci"
        }));
        a.constantPool.put(Integer.MAX_VALUE, new Function("main", new int[] {
            // Store 5 to globals[0]
            Bytecode.CONST, 5,
            Bytecode.GSTORE, 0,
            // Call fibonacci
            Bytecode.CALL, 0,
            // Result should be top-of-stack
            Bytecode.PRINT 
        }));
        //a.execute();
    }
}
